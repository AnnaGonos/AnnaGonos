#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	int a[1000], n;	//количество чисел до 1000
	// Программа должна считать из файла целые числа типа int
	FILE* f = fopen("input.txt", "r");	//открыть файл
	if (f == NULL)	//если ошибка
	{
		printf("Can't open file input.txt\n");	//вывести сообщение
		getchar();
		return 0;	//и выйти
	}
	n = 0;	//кол-во считанных чисел=0
	while (!feof(f))	//продолжаем пока файл не закончится
	{
		if (fscanf(f, "%d", &a[n]) == 1)	//если число считано
		{
			n++;	//увеличить кол-во считанных чисел
		}
	}
	fclose(f);	//закрыть файл
	if (n < 100)	//если меньше 100 элементов считали
	{
		printf("Less than 100 numbers\n");	//вывести сообщение
		getchar();
		return 0;	//и выйти

	}
	//Поиск первых 10 наибольших значений реализовать в виде ассемблерной вставки.
	_asm {               //сортировка выбором
		mov ebx, 0		     // Инициализируется регистр ebx значением 0
		// Этот регистр будет использоваться для отслеживания текущего индекса элемента массива
		mov ecx, 10			 // Инициализируется регистр ecx значением 10
		// Этот регистр указывает, сколько наибольших элементов нужно выбрать

		m4:	                     // метка начала цикла m4
		mov esi, ebx		 	 // Значение регистра ebx (нач. индекс тек. элемента) копируется в регистр esi. 
			// Этот регистр будет испол. для отслеж. тек. индекса массива при поиске мин. элемента
			mov edx, [a + esi * 4]	 // Загружается значение из памяти по адресу a+esi*4 в регистр edx. 
			// Это значение инициализируется как минимальное значение
			mov edi, esi			 // Значение регистра esi копируется в регистр edi. 
			// Регистр edi будет использоваться для хранения индекса минимального элемента

			m3 :	                     // цикл для поиска минимального элемента
		inc esi				 // переходим к следующему элементу; (текущий индекс+1)
			cmp esi, n	         // Сравнивается значение регистра esi с n, размером массива, 
			// чтобы определить, достигнут ли конец массива
			jnc m2				 // Если конец массива не достигнут (нет переноса), 
			// то происходит переход к метке m2, что означает, что поиск минимума продолжается
			cmp[a + esi * 4], edx	 // Сравнивается текущий элемент массива с минимальным значением,которое хранится в регистре edx
			jng m3				 // если текущий элемент не меньше минимального, то переход к метке m3 и продолжаем поиск
			mov edx, [a + esi * 4]	 // Если текущий элемент меньше минимального, то значение текущего элемента загружается в регистр edx
			mov edi, esi			 // и его индекс
			jmp m3				 // Происходит безусловный переход к m3 и продолжаем поиск минимума

			m2 :	                     // следующие три команды меняют местами найденный минимальный элемент
		mov eax, [a + ebx * 4]	 // Загружается значение из памяти по адресу a+ebx*4 в регистр eax
			// Это значение представляет текущий элемент массива, с которого начинается просмотр
			xchg[a + edi * 4], eax	 // Происходит обмен значением текущего элемента массива с минимальным значением,
			// найденным ранее, с использованием регистра eax
			xchg[a + ebx * 4], eax   // Происходит обратный обмен, чтобы вернуть элемент на свое исходное место
			inc ebx	             // Индекс ebx увел.на 1, чтобы перейти к след.элем массива для поиска след.миним
			loop m4				 // Использую loop, чтобы уменьшить значение регистра ecx на 1 и, 
			// если оно не равно 0, выполнить безусловный переход к метке m4. Это продолжает выбор 10 наибольших элементов
	}

	f = fopen("outut.txt", "w");
	for (int i = 0; i < 10; i++) {
		fprintf(f, "%d\n", a[i]);
		printf("%d\n", a[i]);
	}

	fclose(f);
	getchar();

	return 0;
}